# This module makes use of footprint_annotation at
# https://github.com/liangyy/footprint_annotation
# It generates the configfile and sbatch script which is ready to submit a job
# on cluster

def step1_sbatchs(config):
    out = []
    for i in range(config[config['name']]['number_of_chunk']):
        out.append('sbatch/{bed}/cal_prior_bind.{model_tag}.chunk_{i}.sbatch'.format(i=i,
        bed=config['name'],
        model_tag=config['footprint_annotation']['model_tag']))
    return out

def get_all_outputs(config):
    out = []
    for f in config['footprint_annotation'][config['footprint_annotation']['model_tag']].keys():
        out.append('scores/{bed}/{model}/merged.{footprint_bed}.score.gz'.format(footprint_bed=f,
        model=config['footprint_annotation']['model_tag'],
        bed=config['name']))
    return out

def get_all_corrected_outputs(config):
    out = []
    for f in config['footprint_annotation'][config['footprint_annotation']['model_tag']].keys():
        out.append('scores/{bed}/{model}/merged.{footprint_bed}.corrected-score.gz'.format(footprint_bed=f,
        model=config['footprint_annotation']['model_tag'],
        bed=config['name']))
    return out

def get_report(config):
    out = []
    for f in config['footprint_annotation'][config['footprint_annotation']['model_tag']].keys():
        out.append('report/{bed}/{model}/consistency.{footprint_bed}.html'.format(footprint_bed=f,
        model=config['footprint_annotation']['model_tag'],
        bed=config['name']))
    return out

rule all:
    input:
        get_all_outputs(config)

rule all_correct:
    input:
        get_all_corrected_outputs(config)

rule step1:
    input:
        step1_sbatchs(config)

rule report:
    input:
        get_report(config)

rule input_formatting:
    input:
        '../bed2input/chunks/{bed}/chunk_{i}.input.gz'
    output:
        'formatted_input/{bed}/chunk_{i}.finput.gz'
    shell:
        '''zcat {input[0]} | \
        awk -F"\\t" '{{print $1"\\t"$2+1"\\t"$3"\\t"$4"\\t"$5"\\t""placeholder""\\t"NR}}' | \
        gzip > {output[0]}'''

def get_footprint_bed_str(bed_list):
    string = ''
    white = '  '
    string = string + 'footprint_bed:'
    for i in bed_list.keys():
        string = string + "\n{white}{name}: '{path}'".format(white=white, name=i, path=bed_list[i])
    return string

rule prepare_config:
    input:
        'formatted_input/{bed}/chunk_{i}.finput.gz'
    output:
        'configs/{bed}/config.{model_tag}.chunk_{i}.yaml'
    params:
        home_dir = config['snakemake_dir'],
        footprint_bed_str = lambda wildcards: get_footprint_bed_str(config['footprint_annotation'][wildcards.model_tag]),
        include = config['footprint_annotation']['end_include']
    run:
        config = '''{footprint_bed_str}
  end_include: '{end_include}' # 1 for include ; 0 for not include (in original input bed file)
  view: 'zcat'
snp_list:
  {bed}-chunk-{i}:
    path: '{home_dir}/input2score-footprint_annotation/{snp_list}'
    ncol_of_snp_list: 6
    read_first_line: ''
    snp_view_method: 'zcat'
    check_ref: '0'
motif_folder: '../recalibratedMotifs/'
genome: '/project2/xinhe/yanyul/databases/hg19_complete/hg19.fa'
'''.format(footprint_bed_str=params.footprint_bed_str,
            bed=wildcards.bed,
            i=wildcards.i,
            snp_list=input[0],
            home_dir=params.home_dir,
            end_include=params.include)
        o = open(output[0], 'w')
        o.write(config)
        o.close()

rule prepare_sbatch:
    input:
        'formatted_input/{bed}/chunk_{i}.finput.gz',
        'configs/{bed}/config.{model_tag}.chunk_{i}.yaml'
    output:
        'sbatch/{bed}/cal_prior_bind.{model_tag}.chunk_{i}.sbatch'
    run:
        sbatch = '''#!/bin/bash
#SBATCH --job-name={i}-{bed}-{model_tag}.prior_bind
#SBATCH --output={i}-{bed}-{model_tag}.prior_bind.out
#SBATCH --error={i}-{bed}-{model_tag}.prior_bind.err
#SBATCH --time=24:00:00
#SBATCH --partition=broadwl
#SBATCH --mem-per-cpu=50G
#SBATCH --nodes=1

cd /project2/xinhe/yanyul
source setup.sh
source activate deepvarpred_test
# module load cuda/7.5 # load cuda dependency for theano to run on GPU. Now we use the default cuda library on RCC (v4.0)
cd {path}

snakemake --configfile {snakemake_dir}/input2score-footprint_annotation/{config_yaml} run_all_footprint --unlock
snakemake --configfile {snakemake_dir}/input2score-footprint_annotation/{config_yaml} run_all_footprint --rerun-incomplete
'''.format(i=wildcards.i,
           bed=wildcards.bed,
           model_tag=wildcards.model_tag,
           config_yaml=input[1],
           snakemake_dir=config['snakemake_dir'],
           path=config['footprint_annotation']['path_to_annotation'])
        o = open(output[0], 'w')
        o.write(sbatch)
        o.close()

rule output2score:
    input:
        score = lambda wildcards: '{path}/data/prior.{footprint_bed}.{bed}-chunk-{i}.tab.gz'.format(path=config['footprint_annotation']['path_to_annotation'], bed=wildcards.bed, i=wildcards.i, footprint_bed=wildcards.footprint_bed),  # , bed=wildcards.bed, i=wildcards.i)
        snp = lambda wildcards: '{path}/data/footprint_snp.{footprint_bed}.{bed}-chunk-{i}.bed.gz'.format(path=config['footprint_annotation']['path_to_annotation'], bed=wildcards.bed, i=wildcards.i, footprint_bed=wildcards.footprint_bed)
    output:
        'scores/{bed}/{model_tag}/chunk_{i}.{footprint_bed}.score.gz'
    shell:
        'python scripts/output2score.py --input_score {input.score} --input_snp {input.snp} --output {output[0]}'

rule report_consistency:
    input:
        'scores/{bed}/{model_tag}/merged.{footprint_bed}.score.gz',
        lambda wildcards: config['footprint_annotation']['path_to_annotation'] + '/' + config['footprint_annotation'][wildcards.model_tag][wildcards.footprint_bed]
    output:
        temp('report/{bed}/{model_tag}/intersect.{footprint_bed}.bed.gz')
    shell:
        '''bedtools intersect -a <(zcat {input[1]} | awk -F"\\t" -v OFS="\\t" '{{print $1,$2,$3+1,$4,".",$6,$13}}') \
            -b <(zcat {input[0]} | awk -F"\\t" -v OFS="\\t" '{{print $1,$2,$3,$5,$6,$4,$7,$8}}') \
            -s -wa -wb | \
            awk -F"\\t" -v OFS="\\t" '{{if ($4 == $11 && $6 == $13 && $2 == $12) {{print}}}}' | \
            gzip > {output[0]}'''

rule report_rmd:
    params:
        'report/{bed}/{model_tag}/intersect.{footprint_bed}.bed.gz'
    output:
        temp('report/{bed}/{model_tag}/consistency.{footprint_bed}.rmd')
    run:
        rmd = '''---
title: "Consistency between strategy1 log odds ratio of prior and centisnp"
output:
    html_document:
        number_sections: true
        toc: true
        toc_depth: 3
        toc_float: true
author: Yanyu Liang
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{{r setup}}
knitr::opts_knit$set(root.dir = '../../../')
library(stringr)
library(ggplot2)
library(dplyr)
```

# Load data

```{{r}}
data <- read.table('{input}', sep = '\\t', header = F)

v11.good <- is.na(str_match(data$V14, '[ATGC]'))
v11.strategy1 <- str_match(data$V14, '(.+),.+,.+,.+')
v12.good <- is.na(str_match(data$V15, '[ATGC]'))
v12.strategy1 <- str_match(data$V15, '(.+),.+,.+,.+')
strategy1 <- v11.strategy1
strategy1[v12.good, ] <- v12.strategy1[v12.good, ]
# strategy1 <- str_match(data$V12, '(.+),.+,.+,.+')
strategy1 <- strategy1[, 2]
class(strategy1) <- 'numeric'
data <- data.frame(strategy1 = strategy1, centisnp = data$V7, motif = data$V4, position = data$V2, strand = data$V6)
data <- unique(data)
motifs <- unique(data$motif)
```

# Include all motifs

```{{r}}
ggplot(data) + geom_point(aes(x = centisnp, y = strategy1)) +
    geom_abline(slope = 1, intercept = 0, color = 'red') +
    ggtitle('All motifs')
```

```{{r, results='asis'}}
for (i in motifs){{
    data.sub <- data[data$motif == i, ]
    cat('\\n')
    cat("#", paste('Motif', i), "\\n")
    # cat("\\n")
    print(ggplot(data.sub) + geom_point(aes(x = centisnp, y = strategy1)) +
        geom_abline(slope = 1, intercept = 0, color = 'red'))
    # cat("\\n")
    cat("\\n")
}}
```
'''.format(input = params[0])
        o = open(output[0], 'w')
        o.write(rmd)
        o.close()

rule report_html:
    input:
        'report/{bed}/{model_tag}/consistency.{footprint_bed}.rmd',
        'report/{bed}/{model_tag}/intersect.{footprint_bed}.bed.gz'
    output:
        'report/{bed}/{model_tag}/consistency.{footprint_bed}.html'
    shell:
        '''Rscript -e "rmarkdown::render('{input[0]}')"'''

rule generate_reference_model:
    input:
        'report/{bed}/{model_tag}/intersect.{footprint_bed}.bed.gz'
    output:
        'report/{bed}/{model_tag}/consistency.{footprint_bed}.rds'
    shell:
        'Rscript scripts/generate_reference_model.R --reference {input[0]} --output {output[0]}'

rule correct:
    input:
        'scores/{bed}/{model_tag}/chunk_{i}.{footprint_bed}.score.gz',
        'report/{bed}/{model_tag}/consistency.{footprint_bed}.rds'
    output:
        'scores/{bed}/{model_tag}/chunk_{i}.{footprint_bed}.corrected-score.gz'
    shell:
        'Rscript scripts/correct_score.R --score {input[0]} --reference {input[1]} --output {output[0]}'


rule merge_and_sort:
    input:
        files = lambda wildcards: [ 'scores/{bed}/{model_tag}/chunk_{i}.{footprint_bed}.{score_mode}.gz'.format(i=i, model_tag=wildcards.model_tag, bed=wildcards.bed, footprint_bed=wildcards.footprint_bed, score_mode = wildcards.score_mode) for i in range(config[wildcards.bed]['number_of_chunk']) ]
    output:
        'scores/{bed}/{model_tag}/merged.{footprint_bed}.{score_mode}.gz'
    shell:
        'bedtools sort -i <(zcat {input.files}) | gzip > {output[0]}'
